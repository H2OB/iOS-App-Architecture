# 路由设计


iOS 中 APP 间跳转的两种方式：
- URL Scheme：通过在 info.plist 文件中添加 URL types - URL Schemes，再通过 openURL 或者 Safari 中打开链接的方式，即可跳转到指定的 app。此时，该 APP 会在 `application:openURL:sourceApplication:annotation:` 方法中收到回调。
- Universal Links：


页面跳转面临的问题：
- 动态配置，比如点击推送消息、轮播图时，对于如何处理跳转 URL 需要规范化
- 耦合：使用 `pushViewController:`、`presentViewController` 打开新页面时，需要导入 Controller 类
- 一旦要打开的页面出现问题，不能通过动态修改及时规避

### 一、URL 的方式

#### 1. JLRoutes

使用方法：

启动时注册 URL，每个 URL 对应一个 handler，handler 中可以根据解析的参数来决定下一步的任务，比如跳转到一个新页面。注册后可以 openURL: 的方式打开新页面，这个时候注册过 URL 的 handler 就会被调用。

```
JLRoutes *routes = [JLRoutes globalRoutes];

[routes addRoute:@"/user/view/:userID" handler:^BOOL(NSDictionary *parameters) {
    NSString *userID = parameters[@"userID"]; // defined in the route by specifying ":userID"

    // present UI for viewing user with ID 'userID'

    return YES; // return YES to say we have handled the route
}];


NSURL *viewUserURL = [NSURL URLWithString:@"myapp://user/view/joeldev"];
[JLRoutes routeURL:viewUserURL];

```

大概流程：


#### 2. HHRouter

使用方法：

启动时注册 URL，每个 URL 对应一个 controller。注册后可以通过 matchController: 的方式获取到指定 URL 对应的 controller，同时可以通过获取 Controller 的 params 属性（在 category 中定义的）得到解析后的参数。

```
[[HHRouter shared] map:@"/user/view/:userID/" toControllerClass:[UserViewController class]];

UserViewController* userViewController1 = (UserViewController*)[[HHRouter shared] matchController:@"myapp://user/view/joeldev?aa=11&bb=22"];
NSLog(@"%@", userViewController1.params);
```

大概流程：

#### 3. MGJRouter

使用方法跟 JLRoutes 类似，但是提供的 API 更丰富。

```
[MGJRouter registerURLPattern:@"mgj://foo/bar" toHandler:^(NSDictionary *routerParameters) {
    NSLog(@"routerParameterUserInfo:%@", routerParameters[MGJRouterParameterUserInfo]);
}];

[MGJRouter openURL:@"mgj://foo/bar"];

```

大概流程：

处理流程跟 HHRouter 类似。

### 二、target-action 的方式


casa 认为 URL 路由的方式所存在一些问题：
- APP 启动时没必要注册 URL
- 组件间的解耦调用不需要依赖于 openURL，而是为 openURL 服务的

#### 1. APP 启动时没必要注册 URL

在组件化的过程中，注册 URL 并不是充分必要条件，组件是不需要向组件管理器注册 URL 的。而且注册了 URL 之后，会造成不必要的内存常驻。


#### 2. 组件间的解耦调用不需要依赖于 openURL，而是为 openURL 服务的

应该是组件化中的 mediator 为 APP 间的 openURL 提调用供服务，而不是基于 openURL 的方式为组件化提供服务。也就是说，一个App的组件化方案一定不是建立在URL上的，openURL的跨App调用是可以建立在组件化方案上的。

### 参考

- [iOS 组件化 —— 路由设计思路分析](https://www.jianshu.com/p/76da56b3bd55)
- [Support Universal Links](https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html)
- [HHRouter](https://github.com/lightory/HHRouter)
- [JLRoutes](https://github.com/joeldev/JLRoutes)
